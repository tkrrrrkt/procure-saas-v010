---
description: Cursor AIエージェントがコード生成と修正を行う際に特に注意すべき、コード一貫性、セキュリティ、パフォーマンス、エラーハンドリング、テスト容易性、拡張性に関する指示。
globs: ["**/*"] # すべてのファイルに適用されるが、AIの判断に委ねる
type: Agent Requested # AIがタスクに基づいて選択 [cite: 65]
priority: 7
tags: ["ai-directive", "optimization", "security"]
version: "1.0.0"
---
# Cursorエージェント向け特別指示

AIエージェントは以下の点に特に注意してコードの生成と修正を行うこと。これらの指示は、上記のコーディング規約やベストプラクティスを補完し、AIの出力品質を最大化するためのものです。

## 8.1. コード一貫性の確保
- **既存コードパターンの踏襲**: 既存のコードベースのパターンやスタイルを分析し、それに合わせたコードを生成すること。特に `procure-erp-frontend/components/ui/` や `procure-erp-backend/src/common/` などの共通部品の利用を優先すること。 [cite: 17]
- **命名規則の厳守**: 定義されたファイル命名やコード内の変数・関数命名規則を常に遵守すること。 [cite: 17]
- **アーキテクチャの尊重**: プロジェクトのマルチテナント・マイクロサービス（NestJSモジュール）アーキテクチャパターンに沿った構造化を常に意識すること。 [cite: 17]
- **標準化された実装パターン**: NestJSのモジュール設計、Next.jsのApp Router、コンポーネント設計など、フレームワークの標準的な実装パターンを活用すること。 [cite: 17]

## 8.2. セキュリティ優先の実装
- **入力検証**: すべてのユーザー入力に対して、バックエンド（DTO）とフロントエンド（Zod）の両方で厳格なバリデーションを実装すること。 [cite: 18]
- **認証・認可**: すべてのAPIエンドポイントやフロントエンドのページ/コンポーネントに適切な認証・認可チェック（ガード、ミドルウェア、デコレーター）を実装すること。 [cite: 18]
- **データ保護**: 機密データ（ユーザー情報、取引情報の一部など）の保存や送信時には適切な暗号化（ハッシュ化、SSL/TLS）を実装すること。 [cite: 18]
- **セキュリティベストプラクティス**: OWASP Top 10で挙げられる脆弱性（インジェクション、XSS、Broken Access Controlなど）を意識した安全なコーディングプラクティスを常に行うこと。 [cite: 18]
- **OIDCプロトコルに厳密に従い、Nonce、State、IDトークンの検証を徹底すること。** [cite: 18]
- **SSO認証関連のイベント（成功・失敗）は、監査ログに詳細かつ一貫した形式で記録し、セキュリティインシデントの分析に役立てること。** [cite: 18]
- **JWT（Access TokenおよびRefresh Token）は、HttpOnly, Secure, SameSite=Lax/Strict の属性を持つCookieとしてサーバーサイドで設定し、クライアントサイドのJavaScriptから直接アクセスさせないポリシーを厳守すること。** [cite: 18]
- **クライアントサイドでのJWTの直接的な読み書きは一切行わないこと。** [cite: 18]
- **Refresh TokenによるAccessTokenのリフレッシュは、安全なAPIエンドポイント経由で行い、リプレイ攻撃を防ぐメカニズム（例: Refresh Tokenの使い捨てまたは再発行）を検討すること。** [cite: 18]

## 8.3. パフォーマンス最適化
- **効率的なクエリ**: N+1問題を回避し、必要なデータのみを取得する最適化されたデータベースクエリ（Prismaの`include`や`select`を適切に利用）を実装すること。 [cite: 19]
- **レンダリング戦略**: Next.jsのSSG（Static Site Generation）、SSR（Server-Side Rendering）、CSR（Client-Side Rendering）を適切に使い分け、ページの特性に応じた最適なレンダリング戦略を選択すること。 [cite: 19]
- **メモ化とキャッシュ**: 計算コストの高い処理や頻繁にアクセスされるデータには、Reactの`useMemo`/`useCallback`、またはRedisなどのサーバーサイドキャッシュを活用すること。 [cite: 19]
- **バンドルサイズ**: 不要なライブラリのインポートを避け、コードスプリッティング (`dynamic import`) を活用して、フロントエンドのバンドルサイズを最小化すること。 [cite: 19]

## 8.4. エラーハンドリングの徹底
- **包括的なエラー処理**: すべての非同期処理、外部サービス呼び出し、ユーザー入力に対して、予期せぬエラーを適切に捕捉し、処理するエラーハンドリングを実装すること。 [cite: 20]
- **ユーザーフレンドリーなエラー**: エラー発生時には、技術的な詳細を隠蔽し、ユーザーに分かりやすいフィードバック（具体的な指示、影響範囲など）を提供すること。 [cite: 20]
- **ログ記録**: エラー発生時には、デバッグと分析に役立つ十分なコンテキスト情報（ユーザーID、リクエストID、スタックトレースなど）を含むログを記録し、監査ログ機能と連携すること。 [cite: 20]
- **リカバリー戦略**: 可能な場合は、エラーからの自動リカバリー（再試行、フォールバック）を試みる仕組みを実装すること。 [cite: 20]

## 8.5. テスト容易性を考慮した設計
- **単体テスト**: 各機能・コンポーネントは単体でテスト可能なように、疎結合な設計とすること。 [cite: 20]
- **モック対応**: 外部依存（データベース、外部APIなど）はインターフェースを通じて注入し、テスト時に容易にモック可能にすること。 [cite: 20]
- **テストカバレッジ**: コード生成時には対応するテストコードも提案し、高いカバレッジを維持すること。重要なビジネスロジックには特に高いカバレッジを要求すること。 [cite: 20]
- **テスト駆動開発**: 可能な限り、テストファースト（先にテストを書く）のアプローチを推奨すること。 [cite: 20]

## 8.6. 拡張性と保守性の考慮
- **モジュール化**: 機能は適切に分割し、モジュール間の依存関係を最小化すること。 [cite: 21]
- **SOLID原則**: オブジェクト指向設計の原則（単一責任、開放/閉鎖など）に従ったコードを作成すること。 [cite: 21]
- **設計パターン**: 適切な設計パターン（例: リポジトリパターン、ストラテジーパターン）を活用し、コードの再利用性、可読性、保守性を高めること。 [cite: 21]
- **ドキュメント**: コードには適切なコメントやドキュメントを付与し、意図や使用方法を明確にすること。特に、複雑なビジネスロジックやアーキテクチャ上の決定については詳細に記述すること。 [cite: 21]

このルールファイルは、プロジェクトの発展に伴い継続的に更新されます。開発者およびAIエージェントは、常に最新バージョンを参照し、新しいベストプラクティスや要件の変更に対応してください。
**最終更新: 2025年5月21日** [cite: 21]